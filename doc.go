/*
Package yal provides structured logging, in which log messages are expressed as key-value pairs in YAML format.

It is an opinionated logging implementation focusing on human readability as well as ease of parsing by computer programs.

# Philosophy of design

1. Prioritize on human readability

Comparing to regular/unstructured logging, structured logging brings benefits to all roles in the organization, particularly, for the developers and business analysts.  However, most structured logging implemenations give too much focus on machine parsing rather than human readability.  A typical awkward scenario for structured logging is commonly used text or JSON log formats cannot elegantly handle stack trace information for developers to read directly.

The yal package on the other hand uses YAML format to improve readability of log messages while keeping their structured nature. For example:

	// log message with stack trace
	- 20230503_214552.586: test multi-line attr
	  attr: |
	    hello
	    world
	  basename: errors/log
	  client: 127.0.0.1:42392
	  callstack:
	  - (/home/xrfang/git/yal/example/main.go:19) main.task1
	  - (/home/xrfang/git/yal/example/main.go:49) main.main.func3
	  - (/usr/local/go/src/net/http/server.go:2122) net/http.HandlerFunc.ServeHTTP
	  - (/usr/local/go/src/net/http/server.go:2500) net/http.(*ServeMux).ServeHTTP
	  - (/usr/local/go/src/net/http/server.go:2936) net/http.serverHandler.ServeHTTP
	  - (/usr/local/go/src/net/http/server.go:1995) net/http.(*conn).serve

	// log message with hex dump
	- 20230503_214653.571: processing task2...
	  basename: task/log
	  key: |
	    00000000  de ad be ef                                       |....|
	  callstack:
	  - (/home/xrfang/git/yal/example/main.go:23) main.task2

2. Convention over configuration

Unlike other well-known Go logging libraries such as [logrus] or [zap], yal's principle is to use options/switches only when absolutely necessary:

  - YAML is the only format, no TextHandler, JSONHandler or CBORHandler
  - No option to tweak YAML style (e.g. indentation, multi-line text formatting etc.)
  - Timestamp uses current host timezone with millisecond precision. Format is not customizable
  - Only two log levels, "normal" and "debug". See [Let’s talk about logging] by Dave Cheney.

# Basic Usage

STEP 1: Setup handler and global options:

	yal.Setup(func() (yal.Handler, error) {
	    // save logs to /var/logs/myapp, if log file size exceeds
	    // 10MB, archive it and open a new log file. Keep the last
	    // 10 log files.
	    return yal.RotatedHandler("/var/logs/myapp", 10485760, 10)
	})
	yal.Debug(true) //Enable debug logging
	yal.Trace(1)    // add path of source file to every log record

STEP 2: Define and use a log [Emitter]:

	func HandleRequest(w http.ResponseWriter, r *http.Request) {
	    h, _, _ := net.SplitHostPort(r.RemoteAddr)
	    log := yal.NewLogger("basename", filepath.Join("sessions",
	        h)+".log", "method", r.Method)
	    log("handling request", "key1", "val1", "key2", "val2")
	}

While creating an [Emitter], you can add global attributes which are added to all records generated by that Emitter.

	// the example above will generate log records look like:

	- 20230505_111623.456: handling request
	  basename: sessions/127.0.0.1
	  method: GET
	  key1: val1
	  key2: val2

This log message will be appended to file /var/logs/myapp/sessions/127.0.0.1.log, assuming the client connection is from localhost.  This is the purpose of the special attribute "basename", which triages records to their final destination under the root directory of the [RotatedHandler].

# Template string

The first argument of an [Emitter] is the message itself, which must be an string, further arguments are Attributes (see below). Attributes are specified by a serie of key-value pair,
where the key must be a string and value could be any data type. i.e.:

	log(mesg string, attr1 string, val1 any, attr2 string, val2 any, ...)

Log message can contain placeholders for attributes, for example:

	log("received request from {{addr}}", "addr", r.RemoteAddr, "arg1", 3.14)

	will generate log message like:

	- 20230506_143918: received request from 127.0.0.1:23647
	  arg1: 3.14

	Note that attributes used in templates are no longer logged separately below
	the main entry.

# Global Options

There are merely three global options: [Debug], [Trace] and [Peek].

# Attributes

Attributes are internally stored as a map[string]any inside [LogItem]. yal supports all built-in simple data types:

  - string
  - numbers (all variants of int, float and complex)
  - bool
  - error
  - time.Time
  - time.Duration
  - []byte

These data types are converted to string accordingly, notably:

  - multi-line string is rendered in "literal-clip" style (see [YAML multiline string]).
  - numbers are converted to decimal string, unless they are casted by [Hex8], [Hex16], [Hex32], [Hex64] or uintptr, which are converted into hexadecimal string of appropriate width.
  - time.Time is formatted as [time.RFC3339Nano].
  - []byte is rendered by [hex.Dump].

Data types not mentioned above are converted to string by using

	fmt.Sprintf("%v", val)

# Catch and Tracing

This package provides a set of auxiliary functions that mimics traditional try...catch mechanism in other languages like Java.

	// This example catches error at the entry of a function, mitigates the trouble
	// of using if err != nil { return } everywhere.  If errors occur, it will be
	// logged with callstack.
	func dbRelatedOperation() (err error) {
	    defer yal.Catch(&err, attrs...) // attrs is optional contextual arguments
	    db, err := sql.Open(...)
	    yal.Assert(err)
	    ...
	}

	// Caught errors can be filtered.  For example, if "file not exists" is an expected
	// condition, error may be suppressed, or converted to another error if desired.
	func fileRelatedOperation(fn string) (err error) {
	    defer yal.Catch(func(e error) error {
	        if os.IsNotExist(e) {
	            return nil
	        }
			err = e
	        return err
	    }, attrs...)
	    f, err := os.Open(fn)
	    yal.Assert(err)
	    defer f.Close()
	    ...
	}

The global option [Trace] controls how stack tracing is done for non-panic log items. In case of level-1 "brief" tracing, the reported soure file position might not be desired. See the following example:

	func Ret(w http.ResponseWriter, r *http.Request) func() {
	    entry := time.Now()
	    return func() {
	        log("request processed", "elapsed", time.Since(entry))
	    }
	}

	func HandleRequest(w http.ResponseWriter, r * http.Request) {
		defer Ret(w, r)()
		...
	}

The callstack added by yal will indicate that "request processed" is from func Ret(), while the developer may need func HandleRequest(), especially when Ret() is a utility function used in all HTTP request handlers in the application.

To solve this problem, use the [RemoveFromCallStack] function and add "Ret" as a pattern to be removed from callstack. For the sake of clarity, functions from the Go runtime and yal package are always removed.

# Performance considerations

Simple benchmark shows that without using stack tracing, yal is twice as fast as [golang.org/x/exp/slog]

	goos: linux
	goarch: amd64
	pkg: yal
	cpu: Intel(R) Core(TM) i5-7600 CPU @ 3.50GHz
	BenchmarkSlog-4     	 1481678	       806.0 ns/op	       0 B/op	       0 allocs/op
	BenchmarkYal-4      	 3206766	       371.2 ns/op	     434 B/op	       4 allocs/op
	BenchmarkYalRaw-4   	32044741	       35.95 ns/op	      48 B/op	       1 allocs/op
	PASS
	ok  	yal	4.781s

Using stack tracing may significantly slow down logging, because of using [runtime.Caller].  It is recommended to keep the default behavior of only add callstack in case of panics.

Also, it helps to add attributes when creating an [Emitter] or to the [Catch] function rather than as parameters when using the Emitter, because parsing the type of attribute values is a relatively expensive operation.

[logrus]: https://pkg.go.dev/github.com/sirupsen/logrus
[zap]: https://pkg.go.dev/go.uber.org/zap
[Let’s talk about logging]: https://dave.cheney.net/2015/11/05/lets-talk-about-logging
[YAML multiline string]: https://yaml-multiline.info/
*/
package yal
